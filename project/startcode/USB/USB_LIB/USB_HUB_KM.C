/********************************** (C) COPYRIGHT *******************************
* File Name          : USB_HUB_KM.C
* Author             : WCH
* Version            : V1.0
* Date               : 2020/07/06
* Description        : CH545 USB 主机接口函数
*******************************************************************************/                                                  
#include "DEBUG.H"
#include "USB_HUB_KM.H"


UINT8X	RxBuffer[ MAX_PACKET_SIZE ] ;  // IN, must even address
UINT8X	TxBuffer[ MAX_PACKET_SIZE ] ;  // OUT, must even address
#define	pSetupReq	((PXUSB_SETUP_REQ)TxBuffer)
UINT8	RootHubId;		// 当前正在操作的root-hub端口号:0=HUB0,1=HUB1,2=HUB2,3=HUB3
bit		FoundNewDev;
UINT8X	UsbDevEndp0Size;	/* USB设备的端点0的最大包尺寸 */
struct _RootHubDev   xdata RootHubDev[4];
struct _DevOnHubPort xdata DevOnHubPort[4][HUB_MAX_PORTS];
// 获取设备描述符
UINT8C	SetupGetDevDescr[] = { USB_REQ_TYP_IN, USB_GET_DESCRIPTOR, 0x00, USB_DESCR_TYP_DEVICE, 0x00, 0x00, sizeof( USB_DEV_DESCR ), 0x00 };
// 获取配置描述符
UINT8C	SetupGetCfgDescr[] = { USB_REQ_TYP_IN, USB_GET_DESCRIPTOR, 0x00, USB_DESCR_TYP_CONFIG, 0x00, 0x00, 0x04, 0x00 };
// 设置USB地址
UINT8C	SetupSetUsbAddr[] = { USB_REQ_TYP_OUT, USB_SET_ADDRESS, USB_DEVICE_ADDR, 0x00, 0x00, 0x00, 0x00, 0x00 };
// 设置USB配置
UINT8C	SetupSetUsbConfig[] = { USB_REQ_TYP_OUT, USB_SET_CONFIGURATION, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
// 清除端点STALL
UINT8C	SetupClrEndpStall[] = { USB_REQ_TYP_OUT | USB_REQ_RECIP_ENDP, USB_CLEAR_FEATURE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
// 获取HUB描述符
UINT8C	SetupGetHubDescr[] = { HUB_GET_HUB_DESCRIPTOR, HUB_GET_DESCRIPTOR, 0x00, USB_DESCR_TYP_HUB, 0x00, 0x00, sizeof( USB_HUB_DESCR ), 0x00 };


void	DisableRootHubPort( UINT8 RootHubIndex )  // 关闭指定的ROOT-HUB端口,实际上硬件已经自动关闭,此处只是清除一些结构状态
{
	RootHubDev[ RootHubIndex ].DeviceStatus = ROOT_DEV_DISCONNECT;
	RootHubDev[ RootHubIndex ].DeviceAddress = 0x00;
	switch( RootHubIndex ) {
		case 0: UHUB01_CTRL = UHUB01_CTRL & 0xF0 | bUH0_PD_EN; break;  // 清除有关HUB0的控制数据,实际上不需要清除
		case 1: UHUB01_CTRL = UHUB01_CTRL & 0x0F | bUH1_PD_EN; break;  // 清除有关HUB1的控制数据,实际上不需要清除
		case 2: UHUB23_CTRL = UHUB23_CTRL & 0xF0 | bUH2_PD_EN; break;  // 清除有关HUB2的控制数据,实际上不需要清除
		case 3: UHUB23_CTRL = UHUB23_CTRL & 0x0F | bUH3_PD_EN; break;  // 清除有关HUB3的控制数据,实际上不需要清除
		default: break;
	}
}

static UINT8	IsRootHubEnabled( UINT8 RootHubIndex )  // 检查指定的ROOT-HUB端口是否使能
{
	return( ( RootHubIndex < 2 ? UHUB01_CTRL : UHUB23_CTRL ) & ( RootHubIndex & 1 ? bUH1_PORT_EN : bUH0_PORT_EN ) );
}

UINT8	AnalyzeRootHub( void )   // 分析ROOT-HUB状态,处理ROOT-HUB端口的设备插拔事件
// 返回ERR_SUCCESS为没有情况,返回ERR_USB_CONNECT为检测到新连接,返回ERR_USB_DISCON为检测到断开
{ //处理HUB端口的插拔事件,如果设备拔出,函数中调用DisableRootHubPort()函数,将端口关闭,插入事件,置相应端口的状态位
	UINT8	s, i;
	s = ERR_SUCCESS;
	for ( i = 0; i != 4; i ++ ) {
		if ( USB_HUB_ST & ( bUHS_H0_ATTACH << i ) ) {  // 设备存在 bUHS_H?_ATTACH
			if ( RootHubDev[i].DeviceStatus == ROOT_DEV_DISCONNECT  // 检测到有设备插入
				|| IsRootHubEnabled( i ) == 0x00 ) {  // 检测到有设备插入,但尚未允许,说明是刚插入
				DisableRootHubPort( i );  // 关闭端口
				RootHubDev[i].DeviceStatus = ROOT_DEV_CONNECTED;  //置连接标志
				printf( "HUB %x dev in\n", (UINT16)i );
				s = ERR_USB_CONNECT;
			}
		}
		else if ( RootHubDev[i].DeviceStatus >= ROOT_DEV_CONNECTED ) {  //检测到设备拔出
			DisableRootHubPort( i );  // 关闭端口
			printf( "HUB %x dev out\n",  (UINT16)i );
			if ( s == ERR_SUCCESS ) s = ERR_USB_DISCON;
		}
	}
	return( s );
}

void	SetHostUsbAddr( UINT8 addr )  // 设置USB主机当前操作的USB设备地址
{
	USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | addr & 0x7F;
}

void	SetUsbSpeed( UINT8 FullSpeed )  // 设置当前USB速度
{
	if ( FullSpeed ) {  // 全速
		USB_CTRL &= ~ bUC_LOW_SPEED;  // 全速
		UH_SETUP &= ~ bUH_PRE_PID_EN;  // 禁止PRE PID
	}
	else {
		USB_CTRL |= bUC_LOW_SPEED;  // 低速
	}
}

void	ResetRootHubPort( UINT8 RootHubIndex, UINT8 mod )  // 检测到设备后,复位相应端口的总线,为枚举设备准备,设置为默认为全速
// mod: 0=reset and wait end, 1=begin reset, 2=end reset
{
	UsbDevEndp0Size = DEFAULT_ENDP0_SIZE;  /* USB设备的端点0的最大包尺寸 */
	SetHostUsbAddr( 0x00 );
	SetUsbSpeed( 1 );  // 默认为全速
	if ( mod <= 1 ) switch( RootHubIndex ) {
		case 0: UHUB01_CTRL = UHUB01_CTRL & 0xF0 | bUH0_PD_EN | bUH0_BUS_RESET; break;  // 默认为全速,开始复位
		case 1: UHUB01_CTRL = UHUB01_CTRL & 0x0F | bUH1_PD_EN | bUH1_BUS_RESET; break;  // 默认为全速,开始复位
		case 2: UHUB23_CTRL = UHUB23_CTRL & 0xF0 | bUH2_PD_EN | bUH2_BUS_RESET; break;  // 默认为全速,开始复位
		case 3: UHUB23_CTRL = UHUB23_CTRL & 0x0F | bUH3_PD_EN | bUH3_BUS_RESET; break;  // 默认为全速,开始复位
		default: break;
	}
	if ( mod == 0 ) mDelaymS( 11 );  // 复位时间10mS到20mS
	if ( mod != 1 ) switch( RootHubIndex ) {
		case 0: UHUB01_CTRL = UHUB01_CTRL & ~ bUH0_BUS_RESET; break;  // 结束复位
		case 1: UHUB01_CTRL = UHUB01_CTRL & ~ bUH1_BUS_RESET; break;  // 结束复位
		case 2: UHUB23_CTRL = UHUB23_CTRL & ~ bUH2_BUS_RESET; break;  // 结束复位
		case 3: UHUB23_CTRL = UHUB23_CTRL & ~ bUH3_BUS_RESET; break;  // 结束复位
		default: break;
	}
	mDelayuS( 200 );
	UIF_DETECT = 0;  // 清中断标志
}

UINT8	EnableRootHubPort( UINT8 RootHubIndex )  // 使能ROOT-HUB端口,相应的bUH_PORT_EN置1开启端口,设备断开可能导致返回失败
{
	if ( RootHubIndex < 4 ) {
		if ( RootHubDev[ RootHubIndex ].DeviceStatus < ROOT_DEV_CONNECTED ) RootHubDev[ RootHubIndex ].DeviceStatus = ROOT_DEV_CONNECTED;
		if ( USB_HUB_ST & ( bUHS_H0_ATTACH << RootHubIndex ) ) {  // 有设备 bUHS_H?_ATTACH
			if ( IsRootHubEnabled( RootHubIndex ) == 0x00 ) {  // 尚未使能
				RootHubDev[ RootHubIndex ].DeviceSpeed = USB_HUB_ST & ( bUHS_HM0_LEVEL << RootHubIndex ) ? 0 : 1;
				if ( RootHubDev[ RootHubIndex ].DeviceSpeed == 0 ) {
					if ( RootHubIndex < 2 ) UHUB01_CTRL |= RootHubIndex & 1 ? bUH1_LOW_SPEED : bUH0_LOW_SPEED;  // 低速
					else UHUB23_CTRL |= RootHubIndex & 1 ? bUH3_LOW_SPEED : bUH2_LOW_SPEED;  // 低速
				}
			}
			if ( RootHubIndex < 2 ) UHUB01_CTRL |= RootHubIndex & 1 ? bUH1_PORT_EN : bUH0_PORT_EN;  // 使能HUB端口
			else UHUB23_CTRL |= RootHubIndex & 1 ? bUH3_PORT_EN : bUH2_PORT_EN;  // 使能HUB端口
			return( ERR_SUCCESS );
		}
	}
	return( ERR_USB_DISCON );
}

void	SelectHubPort( UINT8 RootHubIndex, UINT8 HubPortIndex )  // HubPortIndex=0选择操作指定的ROOT-HUB端口,否则选择操作指定的ROOT-HUB端口的外部HUB的指定端口
{
	if ( HubPortIndex ) {  // 选择操作指定的ROOT-HUB端口的外部HUB的指定端口
		UsbDevEndp0Size = DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceEp0Size;  // 端点0的长度
		SetHostUsbAddr( DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceAddress );  // 设置USB主机当前操作的USB设备地址
		if ( DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceSpeed == 0 ) {  // 通过外部HUB与低速USB设备通讯需要前置ID
			UH_SETUP |= bUH_PRE_PID_EN;  // 启用PRE PID
		}
		SetUsbSpeed( DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceSpeed );  // 设置当前USB速度
	}
	else {  // 选择操作指定的ROOT-HUB端口
		UsbDevEndp0Size = RootHubDev[RootHubIndex].DeviceEp0Size;  // 端点0的长度
		SetHostUsbAddr( RootHubDev[RootHubIndex].DeviceAddress );  // 设置USB主机当前操作的USB设备地址
		SetUsbSpeed( RootHubDev[RootHubIndex].DeviceSpeed );  // 设置当前USB速度
	}
	RootHubId = RootHubIndex;
}

UINT8	WaitUSB_Interrupt( void )  // 等待USB中断
{
	UINT16	i;
	for ( i = WAIT_USB_TOUT_200US; i != 0 && UIF_TRANSFER == 0; i -- ) CHIP_ID++;
	return( UIF_TRANSFER ? ERR_SUCCESS : ERR_USB_UNKNOWN );
}

// CH545传输事务,输入目的端点地址/PID令牌,同步标志,以20uS为单位的NAK重试总时间(0则不重试,0xFFFF无限重试),返回0成功,超时/出错重试
UINT8	USBHostTransact( UINT8 endp_pid, UINT8 tog, UINT16 timeout )  // endp_pid: 高4位是token_pid令牌, 低4位是端点地址
{  // 本子程序着重于易理解,而在实际应用中,为了提供运行速度,应该对本子程序代码进行优化
	UINT8	TransRetry;
	UINT8   r;
	UINT16	i;
	UH_RX_CTRL = UH_TX_CTRL = tog;
	TransRetry = 0;
	do {
//		LED_TMP = 0;
		UH_EP_PID = endp_pid;  // 指定令牌PID和目的端点号
		UIF_TRANSFER = 0;  // 允许传输
//		s = WaitUSB_Interrupt( );
		for ( i = WAIT_USB_TOUT_200US; i != 0 && UIF_TRANSFER == 0; i -- ) CHIP_ID++;
		UH_EP_PID = 0x00;  // 停止USB传输
//		LED_TMP = 1;
//		if ( s != ERR_SUCCESS ) return( s );  // 中断超时,可能是硬件异常
		if ( UIF_TRANSFER == 0 ) return( ERR_USB_UNKNOWN );
//		if ( UIF_DETECT ) {  // USB设备插拔事件
//			mDelayuS( 200 );  // 等待传输完成
//			UIF_DETECT = 0;  // 清中断标志
//			s = AnalyzeRootHub( );   // 分析ROOT-HUB状态
//			if ( s == ERR_USB_CONNECT ) FoundNewDev = 1;
//			if ( RootHubDev[RootHubId].DeviceStatus == ROOT_DEV_DISCONNECT ) return( ERR_USB_DISCON );  // USB设备断开事件
//			if ( RootHubDev[RootHubId].DeviceStatus == ROOT_DEV_CONNECTED ) return( ERR_USB_CONNECT );  // USB设备连接事件
//			if ( ( USB_HUB_ST & ( bUHS_H0_ATTACH << RootHubId ) ) == 0x00 ) return( ERR_USB_DISCON );  // USB设备断开事件
//			mDelayuS( 200 );  // 等待传输完成
//		}
//		if ( UIF_TRANSFER ) {  // 传输完成
		else {  // 传输完成
			if ( U_TOG_OK ) return( ERR_SUCCESS );
			r = USB_INT_ST & MASK_UIS_H_RES;  // USB设备应答状态
			if ( r == USB_PID_STALL ) return( r | ERR_USB_TRANSFER );
			if ( r == USB_PID_NAK ) {
				if ( timeout == 0 ) return( r | ERR_USB_TRANSFER );
				if ( timeout < 0xFFFF ) timeout --;
				-- TransRetry;
			}
			else switch ( endp_pid >> 4 ) {
				case USB_PID_SETUP:
				case USB_PID_OUT:
//					if ( U_TOG_OK ) return( ERR_SUCCESS );
//					if ( r == USB_PID_ACK ) return( ERR_SUCCESS );
//					if ( r == USB_PID_STALL || r == USB_PID_NAK ) return( r | ERR_USB_TRANSFER );
					if ( r ) return( r | ERR_USB_TRANSFER );  // 不是超时/出错,意外应答
					break;  // 超时重试
				case USB_PID_IN:
//					if ( U_TOG_OK ) return( ERR_SUCCESS );
//					if ( tog ? r == USB_PID_DATA1 : r == USB_PID_DATA0 ) return( ERR_SUCCESS );
//					if ( r == USB_PID_STALL || r == USB_PID_NAK ) return( r | ERR_USB_TRANSFER );
					if ( r == USB_PID_DATA0 && r == USB_PID_DATA1 ) {  // 不同步则需丢弃后重试
					}  // 不同步重试
					else if ( r ) return( r | ERR_USB_TRANSFER );  // 不是超时/出错,意外应答
					break;  // 超时重试
				default:
					return( ERR_USB_UNKNOWN );  // 不可能的情况
					break;
			}
		}
//		else {  // 其它中断,不应该发生的情况
//			USB_INT_FG = 0xFF;  /* 清中断标志 */
//		}
		mDelayuS( 15 );
		if ( UIF_DETECT ) {  // USB设备插拔事件
			if ( IsRootHubEnabled( RootHubId ) == 0 ) return( ERR_USB_DISCON );  // USB设备断开事件
		}
	} while ( ++ TransRetry < 3 );
	return( ERR_USB_TRANSFER );  // 应答超时
}

UINT8	HostCtrlTransfer( PUINT8X DataBuf, PUINT8I RetLen )  // 执行控制传输,8字节请求码在pSetupReq中,DataBuf为可选的收发缓冲区
// 如果需要接收和发送数据,那么DataBuf需指向有效缓冲区用于存放后续数据,实际成功收发的总长度保存在ReqLen指向的字节变量中
{
	UINT8	s, RemLen, RxLen, RxCnt, TxCnt;
	PUINT8X	pBuf;
	PUINT8I	pLen;
	pBuf = DataBuf;
	pLen = RetLen;
	mDelayuS( 200 );
	if ( pLen ) *pLen = 0;  // 实际成功收发的总长度
	UH_TX_LEN = sizeof( USB_SETUP_REQ );
	s = USBHostTransact( USB_PID_SETUP << 4 | 0x00, 0x00, 200000/20 );  // SETUP阶段,200mS超时
	if ( s != ERR_SUCCESS ) return( s );
	UH_RX_CTRL = UH_TX_CTRL = bUH_R_TOG | bUH_R_AUTO_TOG | bUH_T_TOG | bUH_T_AUTO_TOG;  // 默认DATA1
	UH_TX_LEN = 0x01;  // 默认无数据故状态阶段为IN
	RemLen = pSetupReq -> wLengthH ? 0xFF : pSetupReq -> wLengthL;
	if ( RemLen && pBuf ) {  // 需要收发数据
		if ( pSetupReq -> bRequestType & USB_REQ_TYP_IN ) {  // 收
			while ( RemLen ) {
				mDelayuS( 200 );
				s = USBHostTransact( USB_PID_IN << 4 | 0x00, UH_RX_CTRL, 200000/20 );  // IN数据
				if ( s != ERR_SUCCESS ) return( s );
				RxLen = USB_RX_LEN < RemLen ? USB_RX_LEN : RemLen;
				RemLen -= RxLen;
				if ( pLen ) *pLen += RxLen;  // 实际成功收发的总长度
//				memcpy( pBuf, RxBuffer, RxLen );
//				pBuf += RxLen;
				for ( RxCnt = 0; RxCnt != RxLen; RxCnt ++ ) {
					*pBuf = RxBuffer[ RxCnt ];
					pBuf ++;
				}
				if ( USB_RX_LEN == 0 || ( USB_RX_LEN & ( UsbDevEndp0Size - 1 ) ) ) break;  // 短包
			}
			UH_TX_LEN = 0x00;  // 状态阶段为OUT
		}
		else {  // 发
			while ( RemLen ) {
				mDelayuS( 200 );
				UH_TX_LEN = RemLen >= UsbDevEndp0Size ? UsbDevEndp0Size : RemLen;
//				memcpy( TxBuffer, pBuf, UH_TX_LEN );
//				pBuf += UH_TX_LEN;
				for ( TxCnt = 0; TxCnt != UH_TX_LEN; TxCnt ++ ) {
					TxBuffer[ TxCnt ] = *pBuf;
					pBuf ++;
				}
				s = USBHostTransact( USB_PID_OUT << 4 | 0x00, UH_TX_CTRL, 200000/20 );  // OUT数据
				if ( s != ERR_SUCCESS ) return( s );
				RemLen -= UH_TX_LEN;
				if ( pLen ) *pLen += UH_TX_LEN;  // 实际成功收发的总长度
			}
//			UH_TX_LEN = 0x01;  // 状态阶段为IN
		}
	}
	mDelayuS( 200 );
	s = USBHostTransact( ( UH_TX_LEN ? USB_PID_IN << 4 | 0x00: USB_PID_OUT << 4 | 0x00 ), bUH_R_TOG | bUH_T_TOG, 200000/20 );  // STATUS阶段
	if ( s != ERR_SUCCESS ) return( s );
	if ( UH_TX_LEN == 0 ) return( ERR_SUCCESS );  // 状态OUT
	if ( USB_RX_LEN == 0 ) return( ERR_SUCCESS );  // 状态IN,检查IN状态返回数据长度
	return( ERR_USB_BUF_OVER );  // IN状态阶段错误
}

void	CopySetupReqPkg( PUINT8C pReqPkt )  // 复制控制传输的请求包
{
	UINT8	i;
	for ( i = 0; i != sizeof( USB_SETUP_REQ ); i ++ ) {
		((PUINT8X)pSetupReq)[ i ] = *pReqPkt;
		pReqPkt ++;
	}
}

UINT8	CtrlGetDeviceDescr( void )  // 获取设备描述符,返回在TxBuffer中
{
	UINT8	s;
	UINT8D	len;
	UsbDevEndp0Size = DEFAULT_ENDP0_SIZE;
	CopySetupReqPkg( SetupGetDevDescr );
	s = HostCtrlTransfer( TxBuffer, &len );  // 执行控制传输
	if ( s != ERR_SUCCESS ) return( s );
	UsbDevEndp0Size = ( (PXUSB_DEV_DESCR)TxBuffer ) -> bMaxPacketSize0;  // 端点0最大包长度,这是简化处理,正常应该先获取前8字节后立即更新UsbDevEndp0Size再继续
	if ( len < ( (PUSB_SETUP_REQ)SetupGetDevDescr ) -> wLengthL ) return( ERR_USB_BUF_OVER );  // 描述符长度错误
	return( ERR_SUCCESS );
}

UINT8	CtrlGetConfigDescr( void )  // 获取配置描述符,返回在TxBuffer中
{
	UINT8	s;
	UINT8D	len;
	CopySetupReqPkg( SetupGetCfgDescr );
	s = HostCtrlTransfer( TxBuffer, &len );  // 执行控制传输
	if ( s != ERR_SUCCESS ) return( s );
	if ( len < ( (PUSB_SETUP_REQ)SetupGetCfgDescr ) -> wLengthL ) return( ERR_USB_BUF_OVER );  // 返回长度错误
	len = ( (PXUSB_CFG_DESCR)TxBuffer ) -> wTotalLengthL;
	if ( len > MAX_PACKET_SIZE ) return( ERR_USB_BUF_OVER );  // 返回长度错误
	CopySetupReqPkg( SetupGetCfgDescr );
	pSetupReq -> wLengthL = len;  // 完整配置描述符的总长度
	s = HostCtrlTransfer( TxBuffer, &len );  // 执行控制传输
	if ( s != ERR_SUCCESS ) return( s );
	if ( len < ( (PUSB_SETUP_REQ)SetupGetCfgDescr ) -> wLengthL || len < ( (PXUSB_CFG_DESCR)TxBuffer ) -> wTotalLengthL ) return( ERR_USB_BUF_OVER );  // 描述符长度错误
	return( ERR_SUCCESS );
}

UINT8	CtrlSetUsbAddress( UINT8 addr )  // 设置USB设备地址
{
	UINT8	s;
	CopySetupReqPkg( SetupSetUsbAddr );
	pSetupReq -> wValueL = addr;  // USB设备地址
	s = HostCtrlTransfer( NULL, NULL );  // 执行控制传输
	if ( s != ERR_SUCCESS ) return( s );
	SetHostUsbAddr( addr );  // 设置USB主机当前操作的USB设备地址
	mDelaymS( 10 );  // 等待USB设备完成操作
	return( ERR_SUCCESS );
}

UINT8	CtrlSetUsbConfig( UINT8 cfg )  // 设置USB设备配置
{
	CopySetupReqPkg( SetupSetUsbConfig );
	pSetupReq -> wValueL = cfg;  // USB设备配置
	return( HostCtrlTransfer( NULL, NULL ) );  // 执行控制传输
}

UINT8	CtrlClearEndpStall( UINT8 endp )  // 清除端点STALL
{
	CopySetupReqPkg( SetupClrEndpStall );  // 清除端点的错误
	pSetupReq -> wIndexL = endp;  // 端点地址
	return( HostCtrlTransfer( NULL, NULL ) );  /* 执行控制传输 */
}

UINT8	CtrlGetHubDescr( void )  // 获取HUB描述符,返回在TxBuffer中
{
	UINT8	s;
	UINT8D	len;
	CopySetupReqPkg( SetupGetHubDescr );
	s = HostCtrlTransfer( TxBuffer, &len );  // 执行控制传输
	if ( s != ERR_SUCCESS ) return( s );
//	if ( len < ( (PUSB_SETUP_REQ)SetupGetHubDescr ) -> wLengthL ) return( ERR_USB_BUF_OVER );  // 描述符长度错误
	if ( len < 4 ) return( ERR_USB_BUF_OVER );  // 描述符长度错误
	return( ERR_SUCCESS );
}

UINT8	HubGetPortStatus( UINT8 HubPortIndex )  // 查询HUB端口状态,返回在TxBuffer中
{
	UINT8	s;
	UINT8D	len;
	pSetupReq -> bRequestType = HUB_GET_PORT_STATUS;
	pSetupReq -> bRequest = HUB_GET_STATUS;
	pSetupReq -> wValueL = 0x00;
	pSetupReq -> wValueH = 0x00;
	pSetupReq -> wIndexL = HubPortIndex;
	pSetupReq -> wIndexH = 0x00;
	pSetupReq -> wLengthL = 0x04;
	pSetupReq -> wLengthH = 0x00;
	s = HostCtrlTransfer( TxBuffer, &len );  // 执行控制传输
	if ( s != ERR_SUCCESS ) return( s );
	if ( len < 4 ) return( ERR_USB_BUF_OVER );  // 描述符长度错误
	return( ERR_SUCCESS );
}

UINT8	HubSetPortFeature( UINT8 HubPortIndex, UINT8 FeatureSelt )  // 设置HUB端口特性
{
	pSetupReq -> bRequestType = HUB_SET_PORT_FEATURE;
	pSetupReq -> bRequest = HUB_SET_FEATURE;
	pSetupReq -> wValueL = FeatureSelt;
	pSetupReq -> wValueH = 0x00;
	pSetupReq -> wIndexL = HubPortIndex;
	pSetupReq -> wIndexH = 0x00;
	pSetupReq -> wLengthL = 0x00;
	pSetupReq -> wLengthH = 0x00;
	return( HostCtrlTransfer( NULL, NULL ) );  // 执行控制传输
}

UINT8	HubClearPortFeature( UINT8 HubPortIndex, UINT8 FeatureSelt )  // 清除HUB端口特性
{
	pSetupReq -> bRequestType = HUB_CLEAR_PORT_FEATURE;
	pSetupReq -> bRequest = HUB_CLEAR_FEATURE;
	pSetupReq -> wValueL = FeatureSelt;
	pSetupReq -> wValueH = 0x00;
	pSetupReq -> wIndexL = HubPortIndex;
	pSetupReq -> wIndexH = 0x00;
	pSetupReq -> wLengthL = 0x00;
	pSetupReq -> wLengthH = 0x00;
	return( HostCtrlTransfer( NULL, NULL ) );  // 执行控制传输
}

/* ************************************************************************************** */

UINT8	AnalyzeHidIntEndp( PUINT8X buf )  // 从描述符中分析出HID中断端点的地址
{
	UINT8	i, s, l;
	s = 0;
	for ( i = 0; i < ( (PXUSB_CFG_DESCR)buf ) -> wTotalLengthL; i += l ) {  // 搜索中断端点描述符,跳过配置描述符和接口描述符
		if ( ( (PXUSB_ENDP_DESCR)(buf+i) ) -> bDescriptorType == USB_DESCR_TYP_ENDP  // 是端点描述符
			&& ( ( (PXUSB_ENDP_DESCR)(buf+i) ) -> bmAttributes & USB_ENDP_TYPE_MASK ) == USB_ENDP_TYPE_INTER  // 是中断端点
			&& ( ( (PXUSB_ENDP_DESCR)(buf+i) ) -> bEndpointAddress & USB_ENDP_DIR_MASK ) ) {  // 是IN端点
				s = ( (PXUSB_ENDP_DESCR)(buf+i) ) -> bEndpointAddress & USB_ENDP_ADDR_MASK;  // 中断端点的地址
				break;  // 可以根据需要保存wMaxPacketSize和bInterval
		}
		l = ( (PXUSB_ENDP_DESCR)(buf+i) ) -> bLength;  // 当前描述符长度,跳过
		if ( l > 16 ) break;
	}
	return( s );
}

UINT8	InitRootDevice( UINT8 RootHubIndex )  // 初始化指定ROOT-HUB端口的USB设备
// 输入: 内置HUB端口号
{
	UINT8	i, s, cfg, dv_cls, if_cls;
	printf( "Reset root hub %1d# port\n", (UINT16)RootHubIndex );
	ResetRootHubPort( RootHubIndex, 0 );  // 检测到设备后,复位相应端口的USB总线
	for ( i = 0, s = 0; i < 100; i ++ ) {  // 等待USB设备复位后重新连接,100mS超时
		mDelaymS( 1 );
		if ( EnableRootHubPort( RootHubIndex ) == ERR_SUCCESS ) {  // 使能ROOT-HUB端口
			i = 0;
			s ++;  // 计时等待USB设备连接后稳定
			if ( s > 80 ) break;  // 已经稳定连接80mS
		}
	}
	if ( i ) {  // 复位后设备没有连接
		DisableRootHubPort( RootHubIndex );
		printf( "Disable root hub %1d# port because of disconnect\n", (UINT16)RootHubIndex );
		return( ERR_USB_DISCON );
	}
	SelectHubPort( RootHubIndex, 0 );
	printf( "GetDevDescr: " );
	s = CtrlGetDeviceDescr( );  // 获取设备描述符
	if ( s == ERR_SUCCESS ) {
		RootHubDev[RootHubIndex].DeviceEp0Size = UsbDevEndp0Size;  // 端点0的长度
		for ( i = 0; i < ( (PUSB_SETUP_REQ)SetupGetDevDescr ) -> wLengthL; i ++ ) printf( "x%02X ", (UINT16)( TxBuffer[i] ) );
		printf( "\n" ); // 显示出描述符
		dv_cls = ( (PXUSB_DEV_DESCR)TxBuffer ) -> bDeviceClass;  // 设备类代码
		s = CtrlSetUsbAddress( RootHubIndex + ( (PUSB_SETUP_REQ)SetupSetUsbAddr ) -> wValueL );  // 设置USB设备地址,加上RootHubIndex可以保证各HUB端口分配不同的地址
		if ( s == ERR_SUCCESS ) {
			RootHubDev[RootHubIndex].DeviceAddress = RootHubIndex + ( (PUSB_SETUP_REQ)SetupSetUsbAddr ) -> wValueL;  // 保存USB地址
			printf( "GetCfgDescr: " );
			s = CtrlGetConfigDescr( );  // 获取配置描述符
			if ( s == ERR_SUCCESS ) {
				cfg = ( (PXUSB_CFG_DESCR)TxBuffer ) -> bConfigurationValue;
				for ( i = 0; i < ( (PXUSB_CFG_DESCR)TxBuffer ) -> wTotalLengthL; i ++ ) printf( "x%02X ", (UINT16)( TxBuffer[i] ) );
				printf("\n");
/* 分析配置描述符,获取端点数据/各端点地址/各端点大小等,更新变量endp_addr和endp_size等 */
				if_cls = ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceClass;  // 接口类代码
				if ( dv_cls == 0x00 && if_cls == USB_DEV_CLASS_STORAGE ) {  // 是USB存储类设备,基本上确认是U盘
					s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
					if ( s == ERR_SUCCESS ) {
						RootHubDev[RootHubIndex].DeviceStatus = ROOT_DEV_SUCCESS;
						RootHubDev[RootHubIndex].DeviceType = USB_DEV_CLASS_STORAGE;
						printf( "USB-Disk Ready\n" );
						SetUsbSpeed( 1 );  // 默认为全速
						return( ERR_SUCCESS );
					}
				}
				else if ( dv_cls == 0x00 && if_cls == USB_DEV_CLASS_PRINTER && ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceSubClass == 0x01 ) {  // 是打印机类设备
					s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
					if ( s == ERR_SUCCESS ) {
//						需保存端点信息以便主程序进行USB传输
						RootHubDev[RootHubIndex].DeviceStatus = ROOT_DEV_SUCCESS;
						RootHubDev[RootHubIndex].DeviceType = USB_DEV_CLASS_PRINTER;
						printf( "USB-Print Ready\n" );
						SetUsbSpeed( 1 );  // 默认为全速
						return( ERR_SUCCESS );
					}
				}
				else if ( dv_cls == 0x00 && if_cls == USB_DEV_CLASS_HID && ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceSubClass <= 0x01 ) {  // 是HID类设备,键盘/鼠标等
					s = AnalyzeHidIntEndp( TxBuffer );  // 从描述符中分析出HID中断端点的地址
					RootHubDev[RootHubIndex].GpVar = s & USB_ENDP_ADDR_MASK ;  // 保存中断端点的地址,位7用于同步标志位,清0
					if_cls = ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceProtocol;
					s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
					if ( s == ERR_SUCCESS ) {
//						Set_Idle( );
//						需保存端点信息以便主程序进行USB传输
						RootHubDev[RootHubIndex].DeviceStatus = ROOT_DEV_SUCCESS;
						if ( if_cls == 1 ) {
							RootHubDev[RootHubIndex].DeviceType = DEV_TYPE_KEYBOARD;
//							进一步初始化,例如设备键盘指示灯LED等
							printf( "USB-Keyboard Ready\n" );
							SetUsbSpeed( 1 );  // 默认为全速
							return( ERR_SUCCESS );
						}
						else if ( if_cls == 2 ) {
							RootHubDev[RootHubIndex].DeviceType = DEV_TYPE_MOUSE;
//							为了以后查询鼠标状态,应该分析描述符,取得中断端口的地址,长度等信息
							printf( "USB-Mouse Ready\n" );
							SetUsbSpeed( 1 );  // 默认为全速
							return( ERR_SUCCESS );
						}
						s = ERR_USB_UNSUPPORT;
					}
				}
				else if ( dv_cls == USB_DEV_CLASS_HUB ) {  // 是HUB类设备,集线器等
					printf( "GetHubDescr: ");
					s = CtrlGetHubDescr( );
					if ( s == ERR_SUCCESS ) {
						for( i = 0; i < TxBuffer[0]; i++ ) printf( "x%02X ",(UINT16)(TxBuffer[i]) );
						printf("\n");
						RootHubDev[RootHubIndex].GpVar = ( (PXUSB_HUB_DESCR)TxBuffer ) -> bNbrPorts;  // 保存HUB的端口数量
						if ( RootHubDev[RootHubIndex].GpVar > HUB_MAX_PORTS ) RootHubDev[RootHubIndex].GpVar = HUB_MAX_PORTS;  // 因为定义结构DevOnHubPort时人为假定每个HUB不超过HUB_MAX_PORTS个端口
//						if ( ( (PXUSB_HUB_DESCR)TxBuffer ) -> wHubCharacteristics[0] & 0x04 ) printf("带有集线器的复合设备\n");
//						else printf("单一的集线器产品\n");
						s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
						if ( s == ERR_SUCCESS ) {
							RootHubDev[RootHubIndex].DeviceStatus = ROOT_DEV_SUCCESS;
							RootHubDev[RootHubIndex].DeviceType = USB_DEV_CLASS_HUB;
//							需保存端点信息以便主程序进行USB传输,本来中断端点可用于HUB事件通知,但本程序使用查询状态控制传输代替
//							给HUB各端口上电,查询各端口状态,初始化有设备连接的HUB端口,初始化设备
							for ( i = 1; i <= RootHubDev[RootHubIndex].GpVar; i ++ ) {  // 给HUB各端口都上电
								DevOnHubPort[RootHubIndex][i-1].DeviceStatus = ROOT_DEV_DISCONNECT;  // 清外部HUB端口上设备的状态
								s = HubSetPortFeature( i, HUB_PORT_POWER );
								if ( s != ERR_SUCCESS ) printf( "Ext-HUB Port_%1d# power on error\n",(UINT16)i );  // 端口上电失败
							}
							SetUsbSpeed( 1 );  // 默认为全速
							return( ERR_SUCCESS );
						}
					}
				}
				else {   // 可以进一步分析
					s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
					if ( s == ERR_SUCCESS ) {
//						需保存端点信息以便主程序进行USB传输
						RootHubDev[RootHubIndex].DeviceStatus = ROOT_DEV_SUCCESS;
						RootHubDev[RootHubIndex].DeviceStatus = dv_cls ? dv_cls : if_cls;
						SetUsbSpeed( 1 );  // 默认为全速
						return( ERR_SUCCESS );  /* 未知设备初始化成功 */
					}
				}
			}
		}
	}
	printf( "InitRootDev Err = %02X\n", (UINT16)s );
	RootHubDev[RootHubIndex].DeviceStatus = ROOT_DEV_FAILED;
	SetUsbSpeed( 1 );  // 默认为全速
	return( s );
}

UINT8	EnumAllRootDevice( void )  // 枚举所有ROOT-HUB端口的USB设备
{
	UINT8	s, RootHubIndex;
	printf( "EnumAllRootDev\n" );
	for ( RootHubIndex = 0; RootHubIndex != HUB_MAX_PORTS; RootHubIndex ++ ) {
		if ( RootHubDev[RootHubIndex].DeviceStatus == ROOT_DEV_CONNECTED ) {   // 刚插入设备尚未初始化
			s = InitRootDevice( RootHubIndex );  // 初始化/枚举指定HUB端口的USB设备
			if ( s != ERR_SUCCESS ) return( s );
		}
	}
	return( ERR_SUCCESS );
}

UINT8	InitDevOnHub( UINT8 RootHubIndex, UINT8 HubPortIndex )  // 初始化枚举外部HUB后的二级USB设备
{
	UINT8	i, s, cfg, dv_cls, if_cls;
	printf( "Init dev @ExtHub-port_%1d ", (UINT16)HubPortIndex );
	printf( "@Root_%1d\n", (UINT16)RootHubIndex );
	if ( HubPortIndex == 0 ) return( ERR_USB_UNKNOWN );
	SelectHubPort( RootHubIndex, HubPortIndex );  // 选择操作指定的ROOT-HUB端口的外部HUB的指定端口,选择速度
	printf( "GetDevDescr: " );
	s = CtrlGetDeviceDescr( );  // 获取设备描述符
	if ( s != ERR_SUCCESS ) return( s );
	DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceEp0Size = UsbDevEndp0Size;  // 端点0的长度
	dv_cls = ( (PXUSB_DEV_DESCR)TxBuffer ) -> bDeviceClass;  // 设备类代码
	cfg = ( (RootHubIndex+1)<<4 ) + HubPortIndex;  // 计算出一个USB地址,避免地址重叠
	s = CtrlSetUsbAddress( cfg );  // 设置USB设备地址
	if ( s != ERR_SUCCESS ) return( s );
	DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceAddress = cfg;  // 保存分配的USB地址
	printf( "GetCfgDescr: " );
	s = CtrlGetConfigDescr( );  // 获取配置描述符
	if ( s != ERR_SUCCESS ) return( s );
	cfg = ( (PXUSB_CFG_DESCR)TxBuffer ) -> bConfigurationValue;
	for ( i = 0; i < ( (PXUSB_CFG_DESCR)TxBuffer ) -> wTotalLengthL; i ++ ) printf( "x%02X ", (UINT16)( TxBuffer[i] ) );
	printf("\n");
	/* 分析配置描述符,获取端点数据/各端点地址/各端点大小等,更新变量endp_addr和endp_size等 */
	if_cls = ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceClass;  // 接口类代码
	if ( dv_cls == 0x00 && if_cls == USB_DEV_CLASS_STORAGE ) {  // 是USB存储类设备,基本上确认是U盘
		s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
		if ( s == ERR_SUCCESS ) {
			DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceStatus = ROOT_DEV_SUCCESS;
			DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceType = USB_DEV_CLASS_STORAGE;
			printf( "USB-Disk Ready\n" );
			SetUsbSpeed( 1 );  // 默认为全速
			return( ERR_SUCCESS );
		}
	}
	else if ( dv_cls == 0x00 && if_cls == USB_DEV_CLASS_HID && ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceSubClass <= 0x01 ) {  // 是HID类设备,键盘/鼠标等
		s = AnalyzeHidIntEndp( TxBuffer );  // 从描述符中分析出HID中断端点的地址
		DevOnHubPort[RootHubIndex][HubPortIndex-1].GpVar = s;  // 保存中断端点的地址,位7用于同步标志位,清0
		if_cls = ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceProtocol;
		s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
		if ( s == ERR_SUCCESS ) {
//			需保存端点信息以便主程序进行USB传输
			DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceStatus = ROOT_DEV_SUCCESS;
			if ( if_cls == 1 ) {
				DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceType = DEV_TYPE_KEYBOARD;
//				进一步初始化,例如设备键盘指示灯LED等
				printf( "USB-Keyboard Ready\n" );
				SetUsbSpeed( 1 );  // 默认为全速
				return( ERR_SUCCESS );
			}
			else if ( if_cls == 2 ) {
				DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceType = DEV_TYPE_MOUSE;
//				为了以后查询鼠标状态,应该分析描述符,取得中断端口的地址,长度等信息
				printf( "USB-Mouse Ready\n" );
				SetUsbSpeed( 1 );  // 默认为全速
				return( ERR_SUCCESS );
			}
			s = ERR_USB_UNSUPPORT;
		}
	}
	else if ( dv_cls == USB_DEV_CLASS_HUB ) {  // 是HUB类设备,集线器等
		DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceType = USB_DEV_CLASS_HUB;
		printf( "This program don't support Level 2 HUB\n");  // 需要支持多级HUB级联请参考本程序进行扩展
		s = HubClearPortFeature( i, HUB_PORT_ENABLE );  // 禁止HUB端口
		if ( s != ERR_SUCCESS ) return( s );
		s = ERR_USB_UNSUPPORT;
	}
	else {   // 可以进一步分析
		s = CtrlSetUsbConfig( cfg );  // 设置USB设备配置
		if ( s == ERR_SUCCESS ) {
//			需保存端点信息以便主程序进行USB传输
			DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceStatus = ROOT_DEV_SUCCESS;
			DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceType = dv_cls ? dv_cls : if_cls;
			SetUsbSpeed( 1 );  // 默认为全速
			return( ERR_SUCCESS );  /* 未知设备初始化成功 */
		}
	}
	printf( "InitDevOnHub Err = %02X\n", (UINT16)s );
	DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceStatus = ROOT_DEV_FAILED;
	SetUsbSpeed( 1 );  // 默认为全速
	return( s );
}

UINT8	EnumHubPort( UINT8 RootHubIndex )  // 枚举指定ROOT-HUB端口上的外部HUB集线器的各个端口,检查各端口有无连接或移除事件并初始化二级USB设备
{
	UINT8	i, s;
	printf( "EnumHubPort\n" );
	for ( i = 1; i <= RootHubDev[RootHubIndex].GpVar; i ++ ) {  // 查询集线器的端口是否有变化
		SelectHubPort( RootHubIndex, 0 );  // 选择操作指定的ROOT-HUB端口,设置当前USB速度以及被操作设备的USB地址
		s = HubGetPortStatus( i );  // 获取端口状态
		if ( s != ERR_SUCCESS ) return( s );  // 可能是该HUB断开了
		if ( ( TxBuffer[0]&(1<<(HUB_PORT_CONNECTION&0x07)) ) && ( TxBuffer[2]&(1<<(HUB_C_PORT_CONNECTION&0x07)) ) ) {  // 发现有设备连接
			DevOnHubPort[RootHubIndex][i-1].DeviceStatus = ROOT_DEV_CONNECTED;  // 有设备连接
			DevOnHubPort[RootHubIndex][i-1].DeviceAddress = 0x00;
			s = HubGetPortStatus( i );  // 获取端口状态
			if ( s != ERR_SUCCESS ) return( s );  // 可能是该HUB断开了
			DevOnHubPort[RootHubIndex][i-1].DeviceSpeed = TxBuffer[1] & (1<<(HUB_PORT_LOW_SPEED&0x07)) ? 0 : 1;  // 低速还是全速
			if ( DevOnHubPort[RootHubIndex][i-1].DeviceSpeed ) printf( "Found full speed device on port %1d\n", (UINT16)i );
			else printf( "Found low speed device on port %1d\n", (UINT16)i );
			mDelaymS( 200 );  // 等待设备上电稳定	
			s = HubSetPortFeature( i, HUB_PORT_RESET );  // 对有设备连接的端口复位
			if ( s != ERR_SUCCESS ) return( s );  // 可能是该HUB断开了
			printf( "Reset port and then wait in\n" );
			do {  // 查询复位端口,直到复位完成,把完成后的状态显示出来
				mDelaymS( 1 );
				s = HubGetPortStatus( i );
				if ( s != ERR_SUCCESS ) return( s );  // 可能是该HUB断开了
			} while ( TxBuffer[0] & (1<<(HUB_PORT_RESET&0x07)) );  // 端口正在复位则等待
			mDelaymS( 100 );
//			s = HubClearPortFeature( i, C_PORT_RESET ); // 清除复位完成标志
//			s = HubSetPortFeature( i, HUB_PORT_ENABLE );  // 启用HUB端口
			s = HubClearPortFeature( i, HUB_C_PORT_CONNECTION ); // 清除连接或移除变化标志
			if ( s != ERR_SUCCESS ) return( s );
			s = HubGetPortStatus( i );  // 再读取状态,复查设备是否还在
			if ( s != ERR_SUCCESS ) return( s );
			if ( ( TxBuffer[0]&(1<<(HUB_PORT_CONNECTION&0x07)) ) == 0 ) DevOnHubPort[RootHubIndex][i-1].DeviceStatus = ROOT_DEV_DISCONNECT;  // 设备不在了
			s = InitDevOnHub( RootHubIndex, i );  // 初始化二级USB设备
			if ( s != ERR_SUCCESS ) return( s );
			SetUsbSpeed( 1 );  // 默认为全速
		}
		else if ( ( TxBuffer[0]&(1<<(HUB_PORT_CONNECTION&0x07)) ) == 0 ) {  // 设备已经断开
			if ( DevOnHubPort[RootHubIndex][i-1].DeviceStatus >= ROOT_DEV_CONNECTED ) printf( "Device on port %1d removed\n", (UINT16)i );
			DevOnHubPort[RootHubIndex][i-1].DeviceStatus = ROOT_DEV_DISCONNECT;  // 有设备连接
			if ( TxBuffer[2]&(1<<(HUB_C_PORT_CONNECTION&0x07)) ) HubClearPortFeature( i, HUB_C_PORT_CONNECTION ); // 清除移除变化标志
		}
	}
	return( ERR_SUCCESS );  // 返回操作成功
}

UINT8	EnumAllHubPort( void )  // 枚举所有ROOT-HUB端口下外部HUB后的二级USB设备
{
	UINT8	s, RootHubIndex;
	printf( "EnumAllHubPort\n" );
	for ( RootHubIndex = 0; RootHubIndex != 2; RootHubIndex ++ ) {
		if ( RootHubDev[RootHubIndex].DeviceStatus >= ROOT_DEV_SUCCESS && RootHubDev[RootHubIndex].DeviceType == USB_DEV_CLASS_HUB ) {  // HUB枚举成功
			SelectHubPort( RootHubIndex, 0 );  // 选择操作指定的ROOT-HUB端口,设置当前USB速度以及被操作设备的USB地址
//			做点什么?  给HUB各端口上电,查询各端口状态,初始化有设备连接的HUB端口,初始化设备
			s = EnumHubPort( RootHubIndex );  // 枚举指定ROOT-HUB端口上的外部HUB集线器的各个端口,检查各端口有无连接或移除事件
			if ( s != ERR_SUCCESS ) {  // 可能是HUB断开了
				printf( "EnumAllHubPort err = %02X\n", (UINT16)s );
			}
			SetUsbSpeed( 1 );  // 默认为全速
		}
	}
	return( ERR_SUCCESS );
}

UINT16	SearchTypeDevice( UINT8 type )  // 在ROOT-HUB以及外部HUB各端口上搜索指定类型的设备所在的端口号,输出端口号为0xFFFF则未搜索到
{// 输出高8位为ROOT-HUB端口号,低8位为外部HUB的端口号,低8位为0则设备直接在ROOT-HUB端口上
// 当然也可以根据USB的厂商VID产品PID进行搜索(事先要记录各设备的VID和PID),以及指定搜索序号
	UINT8	RootHubIndex, HubPortIndex;
	for ( RootHubIndex = 0; RootHubIndex != HUB_MAX_PORTS; RootHubIndex ++ ) {  // 现时搜索可以避免设备中途拔出而某些信息未及时更新的问题
		if ( RootHubDev[RootHubIndex].DeviceType == type && RootHubDev[RootHubIndex].DeviceStatus >= ROOT_DEV_SUCCESS ) return( (UINT16)RootHubIndex << 8 );  // 类型匹配且枚举成功,在ROOT-HUB端口上
		if ( RootHubDev[RootHubIndex].DeviceType == USB_DEV_CLASS_HUB && RootHubDev[RootHubIndex].DeviceStatus >= ROOT_DEV_SUCCESS ) {  // 外部集线器HUB且枚举成功
			for ( HubPortIndex = 1; HubPortIndex <= RootHubDev[RootHubIndex].GpVar; HubPortIndex ++ ) {  // 搜索外部HUB的各个端口
				if ( DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceType == type && DevOnHubPort[RootHubIndex][HubPortIndex-1].DeviceStatus >= ROOT_DEV_SUCCESS )
					return( ( (UINT16)RootHubIndex << 8 ) | HubPortIndex );  // 类型匹配且枚举成功
			}
		}
	}
	return( 0xFFFF );
}

void	InitUSB_Host( void )  // 初始化USB主机
{
	UINT8	i;
	IE_USB = 0;

	USB_CTRL = bUC_HOST_MODE;  // 先设定模式
	USB_DEV_AD = 0x00;
	UH_EP_MOD = bUH_EP_TX_EN | bUH_EP_RX_EN ;
	UH_RX_DMA = RxBuffer;
	UH_TX_DMA = TxBuffer;
	UH_RX_CTRL = 0x00;
	UH_TX_CTRL = 0x00;
	UHUB23_CTRL = UHUB01_CTRL = bUH1_PD_EN | bUH0_PD_EN;
	USB_CTRL = bUC_HOST_MODE | bUC_INT_BUSY;  // 启动USB主机及DMA,在中断标志未清除前自动暂停
	UH_SETUP = bUH_SOF_EN;
	USB_INT_FG = 0xFF;  // 清中断标志
	for ( i = 0; i != 4; i ++ ) DisableRootHubPort( i );  // 清空
	USB_INT_EN = bUIE_TRANSFER | bUIE_DETECT;
}




